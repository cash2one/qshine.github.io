---
title: 动态规划
date: 2017-06-17 11:03:57
categories: 数据结构和算法
tags:
---



动态规划背后的基本思想: 若要解一个给定问题，我们需要解其不同部分（即子问题），再合并子问题的解以得出原问题的解

适用情况

> - 最优子结构性质。如果问题的最优解所包含的子问题的解也是最优的，我们就称该问题具有最优子结构性质（即满足最优化原理）。最优子结构性质为动态规划算法解决问题提供了重要线索
> - 无后效性。即子问题的解一旦确定，就不再改变，不受在这之后、包含它的更大的问题的求解决策影响
> - 子问题重叠性质。子问题重叠性质是指在用递归算法自顶向下对问题进行求解时，每次产生的子问题并不总是新问题，有些子问题会被重复计算多次。动态规划算法正是利用了这种子问题的重叠性质，对每一个子问题只计算一次，然后将其计算结果保存在一个表格中，当再次需要计算已经计算过的子问题时，只是在表格中简单地查看一下结果，从而获得较高的效率

>  动态规划的本质不是递推或是递归. 动态规划是`某一类问题`的解决方法, 学习动态规划要首先能分辨哪一类问题是动态规划可解的, 哪一类不是.



一个问题是该用递推, 贪心, 搜索还是动态规划, 完全是由这个问题本身阶段间状态的转移方式决定的

- __递推:__ 每个阶段只有一个状态. 例子: 斐波那契数列, 每一个元素都是这个问题的一个状态, 每求一个新数只需要之前的两个状态. 所以同一时刻, 最多只需要保存两个状态. `a[x] = a[x-1] + a[x-2] `. 这种状态很直接, 只需要从旧状态计算出新状态, 不用考虑是不是需要更多的状态, 也不需要考虑选择哪些旧状态来计算
- __贪心算法:__ 每个阶段的最优状态都是由之前所有阶段的最优状态决定的.  即只要保证从开始每一步是最优解, 那么最终结果就是最优解
- __搜索:__ 每个阶段的最优状态是由之前所有阶段的状态的组合得到的. 如走迷宫的最短路径, 那么中间每个阶段都要考虑之前所有阶段的情况, 并不能用贪心算法来求解. 每个阶段的状态或许不多，但是每个状态都可以转移到下一阶段的多个状态，所以解的复杂度就是指数的，因此时间复杂度也是指数的. 之前的路线会影响到下一步的选择, 这种叫做__有后效性__
- __动态规划:__ 每个阶段的最优状态可以从之前某个阶段的某个或某些状态直接得到而不管这个状态是如何得到的. 比如求`最长上升子序列`, 不需要去一次枚举, 每次选择当前数字时, 只需要和之前选定的一个数字比较就行了, 和走迷宫的区别是: 不需要记录之前的所有状态



- 最优子结构
  > 每个阶段的最优状态可以从之前某个阶段的某个或某些状态直接得到


- 无后效性
  > 而不管之前这个状态是如何得到的


<!--more-->

### 使用动态规划的算法

#### 一. 最长公共子序列

有两个序列

- x序列: 有m个元素
- y序列: 有n个元素

如果`x[0] == y[0]`, 那么x和y的最长公共子序列就是`x[1:m]和y[1:n]`的最长公共子序列长度`+1`  
如果`x[0] != y[0]`, 那么x和y的最长公共子序列就是`max(x[:m]和y[1:n]的最长公共子序列, x[1:m]和y[:n]的最长公共子序列)`中长度较大的那个

```python
#!/usr/bin/env python
# coding:utf-8


class LCS(object):
    """
    最长公共子序列
    """
    def lcs_base(self, input_x, input_y):
        if len(input_x) == 0 or len(input_y) == 0:
            return ""
        else:
            a = input_x[0]
            b = input_x[0]
            if a == b:
                return a + self.lcs_base(input_x[1:], input_y[1:])
            else:
                return self.max(self.lcs_base(input_x[1:], input_y), self.lcs_base(input_x, input_y[1:]))

    def max(self, a, b):
        """得到最长的子序列"""
        if len(a) >= len(b):
            return a
        else:
            return b



if __name__ == '__main__':
    l = LCS()
    x = list('1234')
    y = list('12675498')
    print l.lcs_base(x, y)

```

__使用`二维数组`实现__
通过二维数组来模拟填充表格
- 如果两个值相等, 则当前单元格的值为左上角单元格值+1
- 如果两个值不相等, 则当前单元格的值为`max(上方单元格值, 左方单元格值)`

```python
#!/usr/bin/env python
# coding:utf-8

class LCS(object):
    """
    最长公共子序列, 模拟二维数组实现
    """
    def lcs_base(self, x, y):
        res = ""
        x.insert(0, 0)
        y.insert(0, 0)
        table = []
        row = [0]*(len(x))
        for c in range(len(y)):
            table.append(row)
        for j in range(1, len(y)):
            for i in range(1, len(x)):
                if x[i] == y[j]:
                    table[j][i] = table[j-1][i-1] + 1
                    res += x[i]
                else:
                    table[j][i] = max(table[j-1][i], table[j][i-1])
        return res


if __name__ == '__main__':
    x = list('abcde')
    y = list('hcdefds')
    l = LCS()
    print l.lcs_base(x, y)

```


### 参考资料

- `<<图解算法>>`
- [维基百科](https://zh.wikipedia.org/wiki/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92)
- [动态规划解析](https://www.zhihu.com/question/23995189)
- [最长公共子序列-1](http://codepub.cn/2015/07/03/Python-implementation-of-the-longest-common-subsequences/)
- [最长公共子序列-2](http://blog.csdn.net/littlethunder/article/details/25637173)
